------------------172-Problema n+1 sql Active_Record
O problema n+1 esta relacionado com a execucao de n consultas no
banco de dados no caso quando eu coloco na index de subject 
a pesquisa question.subject.description o active_record deixa fazer isso
pelo fato de as tabelas terem relacao uma com a outra.

para resolver isso basta ir no controller de question e inserir um cara chamado 
includes que ai ele ja fara a execucao da query de uma vez

------------------173-Incrementando i18n nos models--------------
Basicamente e para traduzir compas com texto fixo em algumas views

comandos da aula: 
em rails c

a = Subject.all
a.model : pega as informacoes referentes ao model Subject
a.model.human_attribute_name(:description) : verifica se existe na aplicacao um i18n para esse campo 
especificado.

na index de question
<th><%= @questions.model.human_attribute_name(:description)%></th> e faz isso para assuntos tambem
usando a variavel questions criada na aula 172

para nao ficar esse codigo grande foi criado helper para resolver isso
em helper admins_backoffice

def translate_attribute(object = nil, method = nil)
    if object && method
      object.model.human_attribute_name(method)
    else
      puts "Informe os parametros corretamente"
    end
  end

nas views a chamada fica assim:
<%= translate_attribute(@questions, :description)%>

------------------174-I18n com parametros--------------
Basicamente para listar o campo lista de administradores, perguntas e areas
cria outro arquivo i18n
messages.pt-BR.yml:
    listing: Listando %{model} para poder pegar o model que esta sendo traduzido
    messages.confirm_with: deseja realmente excluir %{item}

chamada no view:
      <h2><%=t('messages.listing')%></h2> t e de translate_attribute
    data:{confirm: t('messages.confirm_with', item: subject.description.truncate(25))} final do comando para deletar

-----------------175-3 formas de criar um registro no active_record-------------------
1° forma: Question.create! description: "asdfsadf", subject: Subject.all.sample
    Esse comando cria uma no question pegando um subject sorteado

2° forma: q = Question.new
          q.description = "qualquer coisa"
          q.subject = Subject.all.sample 
          q.save!
    Essa forma vai passando os atributos de forma individual

#
3° forma É a forma como vem sendo feito nos controllers 
    por debaixo dos panos ocorre isso
    params = {question: {description: "qualquer coisa", subject_id: 123}}
        params é um hash que está passando para o model question em forma de hash tambem description e 
        subject_id

  ai para acessar essas informacoes sem dar erro
    params[:question] ai ele acessa as informacoes gravadas

Por fim  Question.create!(params[:question]) cria mais campo na tabela com as informacoes gravadas  
 ou jogar em uma variavel
        a = Question.create!(params[:question]) 
        a.save!

é isso que acontece quando damos um submit no html ele pega as informacoes passadas e cria um hash 
com esses valores e submete ao servidor

------------------------175- Entendendo o Nested Attributes---------------------------------------------------

Serve Basicamente para nao precisarmos criar outro menu para fazer todas as interacoes com o model desejado
No caso Question vai conseguir acessar os atributos de Answer e fazer a criacao  das answers.

no model Question
para fazer a referencia a tabela answer colocou
has_many :answer
e para conseguir pegar os atributos
  accepts_nested_attributes_for :answers, allow_destroy: true


params = {question:
 { description: 'loren ipsun?', subject_id: 1, answers_attributes:[
   {description: 'resposta 1', correct: false},
   {description: 'resposta 2', correct:true},
   {description: 'resposta 3',correct:false}
   ]}}

------------------------176- Adicionando e Atualizando um array de hash------------------

conforme o codigo da aula anterior para conseguir adicionar mais elementos no array com os hash é simple:

params[:question][:answers_attributes] já pega os dados inseridos no array
params[:question][:answers_attributes].push({description: 'resposta 4', correct: false}) já pega os dados inseridos no array
params[:question][:answers_attributes][1] = ({description: 'resposta X', correct: false}) pega os dados da pasição 1 e os altera


------------------------177- Criando uma task para as respostas----------------------------

na task os procedimentos foram parecidos com o que já estava sendo feito
  ficou assim 
  desc "Adiciona perguntas e respostas"
  task add_answers_and_questions: :environment do
    Subject.all.each do |subject|
      rand(5..10).times do |i|
        params = {question: {
          description:  "#{Faker::Lorem.paragraph} #{Faker::Lorem.question}",
          subject: subject,
          answers_attributes: []
        }}      

        #insere respostas no vetor answers_attributes
        rand(2..5).times do |j|
          params[:question][:answers_attributes].push(
            {description: Faker::Lorem.sentence, correct: false}
          )      
        end 

        #atualiza uma das respostas como verdadeira
        index = rand(params[:question][:answers_attributes].size) # faz um sorteio de uma das perguntas
        params[:question][:answers_attributes][index] = {description: Faker::Lorem.sentence, correct: true}
        #cria a pergunta
        Question.create!(params[:question])
      end
    end
  end

----------------------181-Instalando a gem Cocoon----------------------------------
Serve Basicamente para facilitar o trabalho de desenvolver campos na mesma
view que acessam outros models usando nested_attributes

a documentação é bem clara quanto a instalação da lib

em models tem que fazer isso
  belongs_to :subject,  inverse_of: :questions > para não ocorrerem erros na view

  accepts_nested_attributes_for :answers, reject_if: :all_blank, allow_destroy: true > para poder 
  apagar compos que ficaram em branco
no controller
  nos params permit insere
      answers_attributes: [:id, :description, :correct, :_destroy])
---------------------182- Continuçao da instalaçao do Cocoon---------------------------------

no shred_form de questions 























